# Chatbot UI â€” Learning Notes

> ðŸ“Œ **Status**: Implemented on `chatbot` branch, merged into `ui-redesign`.
> **Commits**: `db5a416` (UI) Â· `c7b0c6b` (backend integration)
> **Linear**: SCR-145 Â· SCR-147

---

## What Is the Chatbot Feature?

A full-page AI assistant embedded in the `frontend-v2` React app. Users type natural-language questions about NBA analytics (stats, news, predictions) and receive answers generated by a hybrid RAG+SQL backend engine.

**Architecture at a glance**:
```
User types question
        â†“
useChatbot hook â†’ POST /api/v1/chat
        â†“
Backend: IntentRouter â†’ RAG path or DB path
        â†“
Gemini LLM synthesises answer
        â†“
ChatMessage rendered in ChatbotPanel
```

---

## Component Decomposition (Three-File Pattern)

### Why three files instead of one?

A single monolithic `Chatbot.tsx` would combine:
- Fetch logic with AbortController lifecycle
- Message rendering (markdown, timestamps, role colours)
- Panel layout (header, message list, input form)

Separating these means each unit can change, test, and reuse independently.

### 1. `useChatbot.ts` â€” state and network logic

**Responsibilities**:
- Manages `messages[]`, `loading` flag, `input` string
- Sends `POST /api/v1/chat` with message + history
- Cancels in-flight requests via `AbortController` when component unmounts

```ts
// AbortController pattern â€” prevents "setState on unmounted component" warnings
const controller = new AbortController();

fetch('/api/v1/chat', {
  method: 'POST',
  signal: controller.signal,
  body: JSON.stringify({ message, history }),
});

// Cleanup on unmount:
return () => controller.abort();
```

**Why a custom hook, not Context or Zustand?**
Chat state (`messages`, `loading`, `input`) is scoped entirely to the Chatbot page. No other component ever needs it. Global state would be over-engineering. The hook is the minimum scoping that still keeps side-effect cleanup (AbortController) co-located with the state it protects.

**Future migration path**: If chat history needs to persist across navigation, promote the hook state to Zustand â€” the interface stays the same, only the storage mechanism changes.

### 2. `ChatMessage.tsx` â€” pure rendering

**Responsibilities**:
- Renders a single message bubble (user vs assistant)
- Applies role-based styling (right-aligned amber for user, left-aligned dark for assistant)
- Shows timestamp and optional citation links

**Why extracted?**
- Reusable: can be embedded in a floating widget, a notification panel, or a mobile drawer without reimplementing the bubble logic.
- Pure component: no hooks, no side effects, just `props â†’ JSX`. Easy to snapshot-test.

### 3. `ChatbotPanel.tsx` (inside `Chatbot.tsx`) â€” composition and layout

**Responsibilities**:
- Wires `useChatbot` state to `ChatMessage` list rendering
- Manages auto-scroll to latest message via `useRef` on the message container
- Renders the input form with `onSubmit` â†’ `useChatbot.sendMessage`
- Shows typing indicator when `loading = true`

**Why not inline in `Chatbot.tsx`?**
The panel can be mounted as a sidebar or modal in future iterations. Extracting it means adding a floating chatbot widget later requires zero refactoring â€” just mount `<ChatbotPanel />` wherever needed.

---

## Graceful Degradation Pattern

Before the `/api/v1/chat` backend was ready, the UI was deployed with informative error handling:

```
Backend returns non-200
        â†“
useChatbot catches error
        â†“
Appends assistant message:
"The chat backend isn't reachable right now.
 Start the FastAPI server with: uvicorn main:app --reload"
```

This means the chatbot page is never in an unknown broken state. A hanging spinner is worse UX than an actionable error message.

The same principle appears in:
- `intelligence-layer` (deterministic fallback when Gemini/Chroma unavailable)
- `useApi` hook (explicit `error` state returned to components)

---

## Design Token: Amber `#F59E0B`

The chatbot uses `--accent-chat: #F59E0B` (amber) â€” the same token reserved in the design system before the feature was built.

**Why this matters for interviews**: Using a pre-reserved token instead of inventing a new colour demonstrates respect for the design system contract. Components consume tokens; they don't create new ones. This prevents colour drift as the UI scales.

**Gotcha**: Amber is also used for `--warning` signals. Avoid using amber for error/warning states on the chatbot page â€” use `--error: #EF4444` (red) for failed requests instead.

---

## API Contract

```
POST /api/v1/chat
Content-Type: application/json

{
  "message": "How many points did LeBron average this season?",
  "history": [
    { "role": "user", "content": "..." },
    { "role": "assistant", "content": "..." }
  ],
  "sport": "nba"   // optional, defaults to "nba"
}

Response:
{
  "reply": "LeBron James averaged 25.4 PPG in the 2025-26 season...",
  "path": "db",         // "rag" | "db" | "off_topic"
  "sql_used": "SELECT ...",  // only present on db path
  "citations": []            // only present on rag path
}
```

---

## Interview Angles

> "I applied the three-file component decomposition: hook for state/network logic, ChatMessage for pure rendering, and ChatbotPanel for composition. Each layer is independently testable and reusable."

> "The AbortController in `useChatbot` prevents React's 'setState on unmounted component' warning. When the user navigates away mid-request, the cleanup function cancels the fetch â€” this is production-grade hook design."

> "I used the graceful degradation pattern: the UI is never in a broken state. A contextual error message with instructions is better UX than a hanging spinner, especially during backend development."

## Interview Questions

1. Why use `AbortController` in the chatbot hook?
2. What happens if the user navigates away while a chat response is loading?
3. Why not use Zustand for chatbot state?
4. How would you extend the chatbot to support streaming responses?
5. What triggers the graceful error message, and why is it better than a spinner?
6. How would you add a floating chatbot widget without refactoring existing code?
